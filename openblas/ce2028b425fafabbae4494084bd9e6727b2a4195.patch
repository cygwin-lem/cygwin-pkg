From ce2028b425fafabbae4494084bd9e6727b2a4195 Mon Sep 17 00:00:00 2001
From: "Erik M. Bray" <erik.bray@lri.fr>
Date: Tue, 6 Feb 2018 11:07:56 +0100
Subject: [PATCH] Rewrite this test to work with ctest and re-enable it on the
 appropriate platforms (including Cygwin, which has fork())

---
 Makefile.system   |  1 +
 utest/Makefile    | 10 +++++++++-
 utest/test_fork.c | 20 +++++++++-----------
 3 files changed, 19 insertions(+), 12 deletions(-)

diff --git a/Makefile.system b/Makefile.system
index 5caad0b03..9720b317f 100644
--- a/Makefile.system
+++ b/Makefile.system
@@ -304,6 +304,7 @@ endif
 ifeq ($(OSNAME), CYGWIN_NT)
 NEED_PIC = 0
 NO_EXPRECISION = 1
+OS_CYGWIN_NT = 1
 endif
 
 ifneq ($(OSNAME), WINNT)
diff --git a/utest/Makefile b/utest/Makefile
index ce809e3de..83536afc6 100644
--- a/utest/Makefile
+++ b/utest/Makefile
@@ -12,7 +12,15 @@ OBJS=utest_main.o test_amax.o
 #test_rot.o test_swap.o test_axpy.o test_dotu.o test_rotmg.o test_dsdot.o test_fork.o
 
 ifneq ($(NO_LAPACK), 1)
-OBJS += test_potrs.o
+#OBJS += test_potrs.o
+endif
+
+ifndef OS_WINDOWS
+OBJS += test_fork.o
+else
+ifdef OS_CYGWIN_NT
+OBJS += test_fork.o
+endif
 endif
 
 all : run_test
diff --git a/utest/test_fork.c b/utest/test_fork.c
index e6603902e..e7a8dbcee 100644
--- a/utest/test_fork.c
+++ b/utest/test_fork.c
@@ -31,8 +31,7 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 **********************************************************************************/
 
-#ifndef OS_WINDOWS
-#include "common_utest.h"
+#include "openblas_utest.h"
 #include <sys/wait.h>
 #include <cblas.h>
 
@@ -54,11 +53,11 @@ void check_dgemm(double *a, double *b, double *result, double *expected, int n)
     cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, n, n, n,
         1.0, a, n, b, n, 0.0, result, n);
     for(i = 0; i < n * n; ++i) {
-        CU_ASSERT_DOUBLE_EQUAL(expected[i], result[i], CHECK_EPS);
+        ASSERT_DBL_NEAR_TOL(expected[i], result[i], DOUBLE_EPS);
     }
 }
 
-void test_fork_safety(void)
+CTEST(fork, safety)
 {
     int n = 1000;
     int i;
@@ -89,7 +88,7 @@ void test_fork_safety(void)
 
     fork_pid = fork();
     if (fork_pid == -1) {
-        CU_FAIL("Failed to fork process.");
+        CTEST_ERR("Failed to fork process.");
     } else if (fork_pid == 0) {
         // Compute a DGEMM product in the child process to check that the
         // thread pool as been properly been reinitialized after the fork.
@@ -99,7 +98,7 @@ void test_fork_safety(void)
         // recursively
         fork_pid_nested = fork();
         if (fork_pid_nested == -1) {
-            CU_FAIL("Failed to fork process.");
+            CTEST_ERR("Failed to fork process.");
             exit(1);
         } else if (fork_pid_nested == 0) {
             check_dgemm(a, b, d, c, n);
@@ -108,8 +107,8 @@ void test_fork_safety(void)
             check_dgemm(a, b, d, c, n);
             int child_status = 0;
             pid_t wait_pid = wait(&child_status);
-            CU_ASSERT(wait_pid == fork_pid_nested);
-            CU_ASSERT(WEXITSTATUS (child_status) == 0);
+            ASSERT_EQUAL(wait_pid, fork_pid_nested);
+            ASSERT_EQUAL(0, WEXITSTATUS (child_status));
             exit(0);
         }
     } else {
@@ -117,8 +116,7 @@ void test_fork_safety(void)
         // Wait for the child to finish and check the exit code.
         int child_status = 0;
         pid_t wait_pid = wait(&child_status);
-        CU_ASSERT(wait_pid == fork_pid);
-        CU_ASSERT(WEXITSTATUS (child_status) == 0);
+        ASSERT_EQUAL(wait_pid, fork_pid);
+        ASSERT_EQUAL(0, WEXITSTATUS (child_status));
     }
 }
-#endif
